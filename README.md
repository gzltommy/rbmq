## durable:队列持久化
队列的声明默认是存放到"内存"中的，如果 rabbitmq 重启会丢失，如果想重启之后还存在就要使队列持久化，保存到 Erlang 自带的 Mnesia 数据库中，
当 rabbitmq 重启之后会读取该数据库。

## exclusive:排他
只能由声明它们的连接访问，并且连接关闭时将被删除。其他连接上的频道尝试声明、绑定、使用、清除或删除同名队列将返回错误。简单理解就是在连接关闭时是
否会删除队列（无论队列中有没有消息）

## autoDelete:自动删除
当队列中有消息时，无论是否排他，关闭连接都不会删除队列，此时消费者消费完消息后再断开消费者，队列会被自动删除。（这里如果有多个消费者消费同一个队列，
则需要所有消费者都断开后才能自动删除）,exchange 也是相同的情况。


PS：当一个自动删除的队列被申明后，如果从未出现过任何消费者（调用 Consume方法时使用该队列名），即使队列中没有任何消息了，所有的连接也都断开了，
队列也不会被销毁，直到有消费者出现后，才会发生预期的结果

## ACK:消息确认
在实际应用中，可能会发生消费者收到 Queue 中的消息，但没有处理完成就宕机（或出现其他意外）的情况，这种情况下就可能会导致消息丢失。为了避免这种情况
发生，我们可以要求消费者在消费完消息后发送一个回执给 RabbitMQ，RabbitMQ 收到消息回执（Message acknowledgment）后才将该消息从 Queue 中移除；
如果 RabbitMQ 没有收到回执并检测到消费者的 RabbitMQ 连接断开，则 RabbitMQ 会将该消息发送给其他消费者（如果存在多个消费者）进行处理。这里不存在 
timeout 概念，一个消费者处理消息时间再长也不会导致该消息被发送给其他消费者，除非它的 RabbitMQ 连接断开。 这里会产生另外一个问题，如果我们的开发
人员在处理完业务逻辑后，忘记发送回执给 RabbitMQ，这将会导致严重的 bug —— Queue 中堆积的消息会越来越多；消费者重启后会重复消费这些消息并重复执
行业务逻辑…。

### 消息 ACK 的 2 种情况
+ 自动 ACK：消息一旦被接收，消费者自动发送 ACK 如果消息不太重要，丢失也没有影响，那么自动 ACK 会比较方便
+ 手动 ACK：消息接收后，不会发送 ACK，需要手动调用 如果消息非常重要，不容丢失。

## Rabbitmq 消费消息的模式
rabbitmq 的消费模式分为两种: 推(Push)模式和拉(Pull)模式。推模式采用 Basic.Consume 进行消费，而拉模式则是调用 Basic.Get 模式。

### -Push 模式
+ mq主动将消息推送给消费者（消费者需提供一个消费接口）
+ mq属于主动方，消费者属于一种被动消费，一旦有消息到达mq，会触发mq推送机制，将消息推送给消费者，不管消费者处于何种状态。
+ 优点：
  + 消费者代码较少：对于消费者来说，只需提供一个消费接口给 mq 即可；mq 将接收到的消息，随即推送到指定的消费接口
  + 消息实时性比较高：对于消费者来说，消息一旦到达 mq，mq 会立即推送给消费者。
+ 缺点：
  + 消费者属于被动方，消息量比较大时，对消费者性能要求比较高；若消费者机器资源有限，可能会导致压力过载，引发宕机的情况。
  + 对消费者可用性要求比较高：当消费者不可用时，会导致很 push 失败，在 mq 方需要考虑至少推送成功一次。

### -Pull 模式
+ 消息消费的过程：
  + 消费端采用轮询的方式，从 mq 服务中拉取消息进行消费
  + 消费完成通知 mq 删除已消费成功的消息
  + 继续拉取消息消费
+ 对于消费者来说，是主动方，可以采用线程池的方式，根据机器的性能来增加或缩小线程池的大小，控制拉取消息的速度，可以很好的控制自身的压力。
+ 优点：
  + 消费者可以根据自己的性能主动控制消息拉去的速度，控制自己的压力，不至于把自己弄跨 
  + 消费者属于主动方，控制权更大一些
+ 缺点：
  + 消费方需要实现消息拉取的代码
  + 消费速度较慢时，可能导致 mq 中消息积压，消息消费延迟等。
  + 实时性相对于 push 方式会低一些

### -消费模式的最佳实践
+ 消费者性能较好，对实时性要求比较高的，可以采用 push 的方式
+ 消费者性能有限，建议采用 pull 的方式
+ 整体上来说，主要在于消费者的性能，机器的性能如果没有问题，push 和 pull 都是可以的